/* automatically generated by rust-bindgen 0.59.1 */

pub const HOOKAPI_INCLUDED: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SUCCESS: u32 = 0;
pub const OUT_OF_BOUNDS: i32 = -1;
pub const INTERNAL_ERROR: i32 = -2;
pub const TOO_BIG: i32 = -3;
pub const TOO_SMALL: i32 = -4;
pub const DOESNT_EXIST: i32 = -5;
pub const NO_FREE_SLOTS: i32 = -6;
pub const INVALID_ARGUMENT: i32 = -7;
pub const ALREADY_SET: i32 = -8;
pub const PREREQUISITE_NOT_MET: i32 = -9;
pub const FEE_TOO_LARGE: i32 = -10;
pub const EMISSION_FAILURE: i32 = -11;
pub const TOO_MANY_NONCES: i32 = -12;
pub const TOO_MANY_EMITTED_TXN: i32 = -13;
pub const NOT_IMPLEMENTED: i32 = -14;
pub const INVALID_ACCOUNT: i32 = -15;
pub const GUARD_VIOLATION: i32 = -16;
pub const INVALID_FIELD: i32 = -17;
pub const PARSE_ERROR: i32 = -18;
pub const RC_ROLLBACK: i32 = -19;
pub const RC_ACCEPT: i32 = -20;
pub const NO_SUCH_KEYLET: i32 = -21;
pub const INVALID_FLOAT: i32 = -10024;
pub const KEYLET_HOOK: u32 = 1;
pub const KEYLET_HOOK_STATE: u32 = 2;
pub const KEYLET_ACCOUNT: u32 = 3;
pub const KEYLET_AMENDMENTS: u32 = 4;
pub const KEYLET_CHILD: u32 = 5;
pub const KEYLET_SKIP: u32 = 6;
pub const KEYLET_FEES: u32 = 7;
pub const KEYLET_NEGATIVE_UNL: u32 = 8;
pub const KEYLET_LINE: u32 = 9;
pub const KEYLET_OFFER: u32 = 10;
pub const KEYLET_QUALITY: u32 = 11;
pub const KEYLET_EMITTED_DIR: u32 = 12;
pub const KEYLET_TICKET: u32 = 13;
pub const KEYLET_SIGNERS: u32 = 14;
pub const KEYLET_CHECK: u32 = 15;
pub const KEYLET_DEPOSIT_PREAUTH: u32 = 16;
pub const KEYLET_UNCHECKED: u32 = 17;
pub const KEYLET_OWNER_DIR: u32 = 18;
pub const KEYLET_PAGE: u32 = 19;
pub const KEYLET_ESCROW: u32 = 20;
pub const KEYLET_PAYCHAN: u32 = 21;
pub const KEYLET_EMITTED: u32 = 22;
pub const COMPARE_EQUAL: u32 = 1;
pub const COMPARE_LESS: u32 = 2;
pub const COMPARE_GREATER: u32 = 4;
pub const sfInvalid: i32 = -1;
pub const sfGeneric: u32 = 0;
pub const sfLedgerEntry: u32 = 655491329;
pub const sfTransaction: u32 = 655425793;
pub const sfValidation: u32 = 655556865;
pub const sfMetadata: u32 = 655622401;
pub const sfHash: u32 = 327937;
pub const sfIndex: u32 = 327938;
pub const sfCloseResolution: u32 = 1048577;
pub const sfMethod: u32 = 1048578;
pub const sfTransactionResult: u32 = 1048579;
pub const sfTickSize: u32 = 1048592;
pub const sfUNLModifyDisabling: u32 = 1048593;
pub const sfLedgerEntryType: u32 = 65537;
pub const sfTransactionType: u32 = 65538;
pub const sfSignerWeight: u32 = 65539;
pub const sfVersion: u32 = 65552;
pub const sfFlags: u32 = 131074;
pub const sfSourceTag: u32 = 131075;
pub const sfSequence: u32 = 131076;
pub const sfPreviousTxnLgrSeq: u32 = 131077;
pub const sfLedgerSequence: u32 = 131078;
pub const sfCloseTime: u32 = 131079;
pub const sfParentCloseTime: u32 = 131080;
pub const sfSigningTime: u32 = 131081;
pub const sfExpiration: u32 = 131082;
pub const sfTransferRate: u32 = 131083;
pub const sfWalletSize: u32 = 131084;
pub const sfOwnerCount: u32 = 131085;
pub const sfDestinationTag: u32 = 131086;
pub const sfHighQualityIn: u32 = 131088;
pub const sfHighQualityOut: u32 = 131089;
pub const sfLowQualityIn: u32 = 131090;
pub const sfLowQualityOut: u32 = 131091;
pub const sfQualityIn: u32 = 131092;
pub const sfQualityOut: u32 = 131093;
pub const sfStampEscrow: u32 = 131094;
pub const sfBondAmount: u32 = 131095;
pub const sfLoadFee: u32 = 131096;
pub const sfOfferSequence: u32 = 131097;
pub const sfFirstLedgerSequence: u32 = 131098;
pub const sfLastLedgerSequence: u32 = 131099;
pub const sfTransactionIndex: u32 = 131100;
pub const sfOperationLimit: u32 = 131101;
pub const sfReferenceFeeUnits: u32 = 131102;
pub const sfReserveBase: u32 = 131103;
pub const sfReserveIncrement: u32 = 131104;
pub const sfSetFlag: u32 = 131105;
pub const sfClearFlag: u32 = 131106;
pub const sfSignerQuorum: u32 = 131107;
pub const sfCancelAfter: u32 = 131108;
pub const sfFinishAfter: u32 = 131109;
pub const sfSignerListID: u32 = 131110;
pub const sfSettleDelay: u32 = 131111;
pub const sfHookStateCount: u32 = 131112;
pub const sfHookReserveCount: u32 = 131113;
pub const sfHookDataMaxSize: u32 = 131114;
pub const sfEmitGeneration: u32 = 131115;
pub const sfIndexNext: u32 = 196609;
pub const sfIndexPrevious: u32 = 196610;
pub const sfBookNode: u32 = 196611;
pub const sfOwnerNode: u32 = 196612;
pub const sfBaseFee: u32 = 196613;
pub const sfExchangeRate: u32 = 196614;
pub const sfLowNode: u32 = 196615;
pub const sfHighNode: u32 = 196616;
pub const sfDestinationNode: u32 = 196617;
pub const sfCookie: u32 = 196618;
pub const sfServerVersion: u32 = 196619;
pub const sfEmitBurden: u32 = 196620;
pub const sfHookOn: u32 = 196624;
pub const sfEmailHash: u32 = 262145;
pub const sfTakerPaysCurrency: u32 = 1114113;
pub const sfTakerPaysIssuer: u32 = 1114114;
pub const sfTakerGetsCurrency: u32 = 1114115;
pub const sfTakerGetsIssuer: u32 = 1114116;
pub const sfLedgerHash: u32 = 327681;
pub const sfParentHash: u32 = 327682;
pub const sfTransactionHash: u32 = 327683;
pub const sfAccountHash: u32 = 327684;
pub const sfPreviousTxnID: u32 = 327685;
pub const sfLedgerIndex: u32 = 327686;
pub const sfWalletLocator: u32 = 327687;
pub const sfRootIndex: u32 = 327688;
pub const sfAccountTxnID: u32 = 327689;
pub const sfEmitParentTxnID: u32 = 327690;
pub const sfEmitNonce: u32 = 327691;
pub const sfBookDirectory: u32 = 327696;
pub const sfInvoiceID: u32 = 327697;
pub const sfNickname: u32 = 327698;
pub const sfAmendment: u32 = 327699;
pub const sfTicketID: u32 = 327700;
pub const sfDigest: u32 = 327701;
pub const sfPayChannel: u32 = 327702;
pub const sfConsensusHash: u32 = 327703;
pub const sfCheckID: u32 = 327704;
pub const sfValidatedHash: u32 = 327705;
pub const sfAmount: u32 = 393217;
pub const sfBalance: u32 = 393218;
pub const sfLimitAmount: u32 = 393219;
pub const sfTakerPays: u32 = 393220;
pub const sfTakerGets: u32 = 393221;
pub const sfLowLimit: u32 = 393222;
pub const sfHighLimit: u32 = 393223;
pub const sfFee: u32 = 393224;
pub const sfSendMax: u32 = 393225;
pub const sfDeliverMin: u32 = 393226;
pub const sfMinimumOffer: u32 = 393232;
pub const sfRippleEscrow: u32 = 393233;
pub const sfDeliveredAmount: u32 = 393234;
pub const sfPublicKey: u32 = 458753;
pub const sfMessageKey: u32 = 458754;
pub const sfSigningPubKey: u32 = 458755;
pub const sfTxnSignature: u32 = 458756;
pub const sfSignature: u32 = 458758;
pub const sfDomain: u32 = 458759;
pub const sfFundCode: u32 = 458760;
pub const sfRemoveCode: u32 = 458761;
pub const sfExpireCode: u32 = 458762;
pub const sfCreateCode: u32 = 458763;
pub const sfMemoType: u32 = 458764;
pub const sfMemoData: u32 = 458765;
pub const sfMemoFormat: u32 = 458766;
pub const sfFulfillment: u32 = 458768;
pub const sfCondition: u32 = 458769;
pub const sfMasterSignature: u32 = 458770;
pub const sfUNLModifyValidator: u32 = 458771;
pub const sfNegativeUNLToDisable: u32 = 458772;
pub const sfNegativeUNLToReEnable: u32 = 458773;
pub const sfHookData: u32 = 458774;
pub const sfAccount: u32 = 524289;
pub const sfOwner: u32 = 524290;
pub const sfDestination: u32 = 524291;
pub const sfIssuer: u32 = 524292;
pub const sfAuthorize: u32 = 524293;
pub const sfUnauthorize: u32 = 524294;
pub const sfTarget: u32 = 524295;
pub const sfRegularKey: u32 = 524296;
pub const sfPaths: u32 = 1179649;
pub const sfIndexes: u32 = 1245185;
pub const sfHashes: u32 = 1245186;
pub const sfAmendments: u32 = 1245187;
pub const sfTransactionMetaData: u32 = 917506;
pub const sfCreatedNode: u32 = 917507;
pub const sfDeletedNode: u32 = 917508;
pub const sfModifiedNode: u32 = 917509;
pub const sfPreviousFields: u32 = 917510;
pub const sfFinalFields: u32 = 917511;
pub const sfNewFields: u32 = 917512;
pub const sfTemplateEntry: u32 = 917513;
pub const sfMemo: u32 = 917514;
pub const sfSignerEntry: u32 = 917515;
pub const sfEmitDetails: u32 = 917516;
pub const sfSigner: u32 = 917520;
pub const sfMajority: u32 = 917522;
pub const sfNegativeUNLEntry: u32 = 917523;
pub const sfSigningAccounts: u32 = 983042;
pub const sfSigners: u32 = 983043;
pub const sfSignerEntries: u32 = 983044;
pub const sfTemplate: u32 = 983045;
pub const sfNecessary: u32 = 983046;
pub const sfSufficient: u32 = 983047;
pub const sfAffectedNodes: u32 = 983048;
pub const sfMemos: u32 = 983049;
pub const sfMajorities: u32 = 983056;
pub const sfNegativeUNL: u32 = 983057;
pub const HOOKMACROS_INCLUDED: u32 = 1;
pub const ttPAYMENT: u32 = 0;
pub const tfCANONICAL: u32 = 2147483648;
pub const atACCOUNT: u32 = 1;
pub const atOWNER: u32 = 2;
pub const atDESTINATION: u32 = 3;
pub const atISSUER: u32 = 4;
pub const atAUTHORIZE: u32 = 5;
pub const atUNAUTHORIZE: u32 = 6;
pub const atTARGET: u32 = 7;
pub const atREGULARKEY: u32 = 8;
pub const atPSEUDOCALLBACK: u32 = 9;
pub const amAMOUNT: u32 = 1;
pub const amBALANCE: u32 = 2;
pub const amLIMITAMOUNT: u32 = 3;
pub const amTAKERPAYS: u32 = 4;
pub const amTAKERGETS: u32 = 5;
pub const amLOWLIMIT: u32 = 6;
pub const amHIGHLIMIT: u32 = 7;
pub const amFEE: u32 = 8;
pub const amSENDMAX: u32 = 9;
pub const amDELIVERMIN: u32 = 10;
pub const amMINIMUMOFFER: u32 = 16;
pub const amRIPPLEESCROW: u32 = 17;
pub const amDELIVEREDAMOUNT: u32 = 18;
pub const ENCODE_TL_SIZE: u32 = 49;
pub const ENCODE_DROPS_SIZE: u32 = 9;
pub const ENCODE_TT_SIZE: u32 = 3;
pub const ENCODE_ACCOUNT_SIZE: u32 = 22;
pub const ENCODE_ACCOUNT_SRC_SIZE: u32 = 22;
pub const ENCODE_ACCOUNT_DST_SIZE: u32 = 22;
pub const ENCODE_UINT32_COMMON_SIZE: u32 = 5;
pub const ENCODE_UINT32_UNCOMMON_SIZE: u32 = 6;
pub const ENCODE_LLS_SIZE: u32 = 6;
pub const ENCODE_FLS_SIZE: u32 = 6;
pub const ENCODE_TAG_SRC_SIZE: u32 = 5;
pub const ENCODE_TAG_DST_SIZE: u32 = 5;
pub const ENCODE_SEQUENCE_SIZE: u32 = 5;
pub const ENCODE_FLAGS_SIZE: u32 = 5;
pub const ENCODE_SIGNING_PUBKEY_SIZE: u32 = 35;
pub const ENCODE_SIGNING_PUBKEY_NULL_SIZE: u32 = 35;
pub const PREPARE_PAYMENT_SIMPLE_SIZE: u32 = 237;
pub const PREPARE_PAYMENT_SIMPLE_TRUSTLINE_SIZE: u32 = 277;
extern "C" {
    pub fn hook(reserved: i64) -> i64;
}
extern "C" {
    pub fn cbak(reserved: i64) -> i64;
}
extern "C" {
    #[doc = " Guard function. Each time a loop appears in your code a call to this must be the first branch instruction after the"]
    #[doc = " beginning of the loop."]
    #[doc = " @param id The identifier of the guard (typically the line number)."]
    #[doc = " @param maxiter The maximum number of times this loop will iterate across the life of the hook."]
    #[doc = " @return Can be ignored. If the guard is violated the hook will terminate."]
    pub fn _g(id: u32, maxiter: u32) -> i32;
}
extern "C" {
    #[doc = " Accept the originating transaction and commit all hook state changes and submit all emitted transactions."]
    #[doc = " @param read_ptr An optional string to use as a return comment. May be 0."]
    #[doc = " @param read_len The length of the string. May be 0."]
    #[doc = " @return Will never return, terminates the hook."]
    pub fn accept(read_ptr: u32, read_len: u32, error_code: i64) -> i64;
}
extern "C" {
    #[doc = " Rollback the originating transaction, discard all hook state changes and emitted transactions."]
    #[doc = " @param read_ptr An optional string to use as a return comment. May be 0."]
    #[doc = " @param read_len The length of the string. May be 0."]
    #[doc = " @return Will never return, terminates the hook."]
    pub fn rollback(read_ptr: u32, read_len: u32, error_code: i64) -> i64;
}
extern "C" {
    #[doc = " Read a 20 byte account-id from the memory pointed to by read_ptr of length read_len and encode it to a base58-check"]
    #[doc = " encoded r-address."]
    #[doc = " @param read_ptr The memory address of the account-id"]
    #[doc = " @param read_len The byte length of the account-id (should always be 20)"]
    #[doc = " @param write_ptr The memory address of a suitable buffer to write the encoded r-address into."]
    #[doc = " @param write_len The size of the write buffer."]
    #[doc = " @return On success the length of the r-address will be returned indicating the bytes written to the write buffer."]
    #[doc = "         On failure a negative integer is returned indicating what went wrong."]
    pub fn util_raddr(write_ptr: u32, write_len: u32, read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    #[doc = " Read an r-address from the memory pointed to by read_ptr of length read_len and decode it to a 20 byte account id"]
    #[doc = " and write to write_ptr"]
    #[doc = " @param read_ptr The memory address of the r-address"]
    #[doc = " @param read_len The byte length of the r-address"]
    #[doc = " @param write_ptr The memory address of a suitable buffer to write the decoded account id into."]
    #[doc = " @param write_len The size of the write buffer."]
    #[doc = " @return On success 20 will be returned indicating the bytes written. On failure a negative integer is returned"]
    #[doc = "         indicating what went wrong."]
    pub fn util_accid(write_ptr: u32, write_len: u32, read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    #[doc = " Verify a cryptographic signature either ED25519 of SECP256k1. Public key should be prefixed with 0xED for 25519."]
    #[doc = " @param dread_ptr The memory location of the data or payload to verify"]
    #[doc = " @param dread_len The length of the data or payload to verify"]
    #[doc = " @param sread_ptr The memory location of the signature"]
    #[doc = " @param sread_len The length of the signature"]
    #[doc = " @param kread_ptr The memory location of the public key"]
    #[doc = " @param kread_len The length of the public key"]
    #[doc = " @return True if and only if the signature was verified."]
    pub fn util_verify(
        dread_ptr: u32,
        dread_len: u32,
        sread_ptr: u32,
        sread_len: u32,
        kread_ptr: u32,
        kread_len: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Compute the first half of a SHA512 checksum."]
    #[doc = " @param write_ptr The buffer to write the checksum into. Must be at least 32 bytes."]
    #[doc = " @param write_len The length of the buffer."]
    #[doc = " @param read_ptr  The buffer to read data for digest from."]
    #[doc = " @param read_len  The amount of data to read from the buffer."]
    #[doc = " @return The number of bytes written to write_ptr or a negative integer on error."]
    pub fn util_sha512h(write_ptr: u32, write_len: u32, read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    #[doc = " Index into a xrpld serialized object and return the location and length of a subfield. Except for Array subtypes"]
    #[doc = " the offset and length refer to the **payload** of the subfield not the entire subfield. Use SUB_OFFSET and"]
    #[doc = " SUB_LENGTH macros to extract return value."]
    #[doc = " @param read_ptr The memory location of the stobject"]
    #[doc = " @param read_len The length of the stobject"]
    #[doc = " @param field_id The Field Code of the subfield"]
    #[doc = " @return high-word (most significant 4 bytes excluding the most significant bit (MSB)) is the field offset relative"]
    #[doc = "         to read_ptr and the low-word (least significant 4 bytes) is its length. MSB is sign bit, if set (negative)"]
    #[doc = "         return value indicates error (typically error means could not find.)"]
    pub fn sto_subfield(read_ptr: u32, read_len: u32, field_id: u32) -> i64;
}
extern "C" {
    #[doc = " Index into a xrpld serialized array and return the location and length of an index. Unlike sto_subfield this api"]
    #[doc = " always returns the offset and length of the whole object at that index (not its payload.) Use SUB_OFFSET and"]
    #[doc = " SUB_LENGTH macros to extract return value."]
    #[doc = " @param read_ptr The memory location of the stobject"]
    #[doc = " @param read_len The length of the stobject"]
    #[doc = " @param array_id The index requested"]
    #[doc = " @return high-word (most significant 4 bytes excluding the most significant bit (MSB)) is the field offset relative"]
    #[doc = "         to read_ptr and the low-word (least significant 4 bytes) is its length. MSB is sign bit, if set (negative)"]
    #[doc = "         return value indicates error (typically error means could not find.)"]
    pub fn sto_subarray(read_ptr: u32, read_len: u32, array_id: u32) -> i64;
}
extern "C" {
    pub fn sto_validate(read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    pub fn sto_emplace(
        write_ptr: u32,
        write_len: u32,
        sread_ptr: u32,
        sread_len: u32,
        fread_ptr: u32,
        fread_len: u32,
        field_id: u32,
    ) -> i64;
}
extern "C" {
    pub fn sto_erase(
        write_ptr: u32,
        write_len: u32,
        read_ptr: u32,
        read_len: u32,
        field_id: u32,
    ) -> i64;
}
extern "C" {
    pub fn util_keylet(
        write_ptr: u32,
        write_len: u32,
        keylet_type: u32,
        a: u32,
        b: u32,
        c: u32,
        d: u32,
        e: u32,
        f: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Compute burden for an emitted transaction."]
    #[doc = " @return the burden a theoretically emitted transaction would have."]
    pub fn etxn_burden() -> i64;
}
extern "C" {
    #[doc = " Write a full emit_details stobject into the buffer specified."]
    #[doc = " @param write_ptr A sufficiently large buffer to write into."]
    #[doc = " @param write_len The length of that buffer."]
    #[doc = " @return The number of bytes written or a negative integer indicating an error."]
    pub fn etxn_details(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Compute the minimum fee required to be paid by a hypothetically emitted transaction based on its size in bytes."]
    #[doc = " @param The size of the emitted transaction in bytes"]
    #[doc = " @return The minimum fee in drops this transaction should pay to succeed"]
    pub fn etxn_fee_base(tx_byte_count: u32) -> i64;
}
extern "C" {
    #[doc = " Inform xrpld that you will be emitting at most @count@ transactions during the course of this hook execution."]
    #[doc = " @param count The number of transactions you intend to emit from this  hook."]
    #[doc = " @return If a negaitve integer an error has occured"]
    pub fn etxn_reserve(count: u32) -> i64;
}
extern "C" {
    #[doc = " Compute the generation of an emitted transaction. If this hook was invoked by a transaction emitted by a previous"]
    #[doc = " hook then the generation counter will be 1+ the previous generation counter otherwise it will be 1."]
    #[doc = " @return The generation of a hypothetically emitted transaction."]
    pub fn etxn_generation() -> i64;
}
extern "C" {
    #[doc = " Emit a transaction from this hook."]
    #[doc = " @param read_ptr Memory location of a buffer containing the fully formed binary transaction to emit."]
    #[doc = " @param read_len The length of the transaction."]
    #[doc = " @return A negative integer if the emission failed."]
    pub fn emit(write_ptr: u32, write_len: u32, read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve the account the hook is running on."]
    #[doc = " @param write_ptr A buffer of at least 20 bytes to write into."]
    #[doc = " @param write_len The length of that buffer"]
    #[doc = " @return The number of bytes written into the buffer of a negative integer if an error occured."]
    pub fn hook_account(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve the hash of the currently executing hook."]
    #[doc = " @param write_ptr A buffer of at least 32 bytes to write into."]
    #[doc = " @param write_len The length of that buffer"]
    #[doc = " @return The number of bytes written into the buffer of a negative integer if an error occured."]
    pub fn hook_hash(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrive the currently recommended minimum fee for a transaction to succeed."]
    pub fn fee_base() -> i64;
}
extern "C" {
    #[doc = " Retrieve the current ledger sequence number"]
    pub fn ledger_seq() -> i64;
}
extern "C" {
    pub fn ledger_last_hash(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve a nonce for use in an emitted transaction (or another task). Can be called repeatedly for multiple nonces."]
    #[doc = " @param write_ptr A buffer of at least 32 bytes to write into."]
    #[doc = " @param write_len The length of that buffer"]
    #[doc = " @return The number of bytes written into the buffer of a negative integer if an error occured."]
    pub fn nonce(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Slot functions have not been implemented yet and the api for them is subject to change"]
    pub fn slot(write_ptr: u32, write_len: u32, slot: u32) -> i64;
}
extern "C" {
    pub fn slot_clear(slot: u32) -> i64;
}
extern "C" {
    pub fn slot_count(slot: u32) -> i64;
}
extern "C" {
    pub fn slot_id(slot: u32) -> i64;
}
extern "C" {
    pub fn slot_set(read_ptr: u32, read_len: u32, slot: i32) -> i64;
}
extern "C" {
    pub fn slot_size(slot: u32) -> i64;
}
extern "C" {
    pub fn slot_subarray(parent_slot: u32, array_id: u32, new_slot: u32) -> i64;
}
extern "C" {
    pub fn slot_subfield(parent_slot: u32, field_id: u32, new_slot: u32) -> i64;
}
extern "C" {
    pub fn slot_type(slot: u32, flags: u32) -> i64;
}
extern "C" {
    pub fn slot_float(slot: u32) -> i64;
}
extern "C" {
    pub fn trace_slot(mread_ptr: u32, mread_len: u32, slot: u32) -> i64;
}
extern "C" {
    pub fn otxn_slot(slot: u32) -> i64;
}
extern "C" {
    #[doc = " In the hook's state key-value map, set the value for the key pointed at by kread_ptr."]
    #[doc = " @param read_ptr A buffer containing the data to store"]
    #[doc = " @param read_len The length of the data"]
    #[doc = " @param kread_ptr A buffer containing the key"]
    #[doc = " @param kread_len The length of the key"]
    #[doc = " @return The number of bytes stored or a negative integer if an error occured"]
    pub fn state_set(read_ptr: u32, read_len: u32, kread_ptr: u32, kread_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve a value from the hook's key-value map."]
    #[doc = " @param write_ptr A buffer to write the state value into"]
    #[doc = " @param write_len The length of that buffer"]
    #[doc = " @param kread_ptr A buffer to read the state key from"]
    #[doc = " @param kread_len The length of that key"]
    #[doc = " @return The number of bytes written or a negative integer if an error occured."]
    pub fn state(write_ptr: u32, write_len: u32, kread_ptr: u32, kread_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve a value from another hook's key-value map."]
    #[doc = " @param write_ptr A buffer to write the state value into"]
    #[doc = " @param write_len The length of that buffer"]
    #[doc = " @param kread_ptr A buffer to read the state key from"]
    #[doc = " @param kread_len The length of that key"]
    #[doc = " @param aread_ptr A buffer containing an account-id of another account containing a hook whose state we are reading"]
    #[doc = " @param aread_len The length of the account-id (should always be 20)."]
    #[doc = " @return The number of bytes written or a negative integer if an error occured."]
    pub fn state_foreign(
        write_ptr: u32,
        write_len: u32,
        kread_ptr: u32,
        kread_len: u32,
        aread_ptr: u32,
        aread_len: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Print some output to the trace log on xrpld. Any xrpld instance set to \"trace\" log level will see this."]
    #[doc = " @param read_ptr A buffer containing either data or text (in either utf8, or utf16le)"]
    #[doc = " @param read_len The byte length of the data/text to send to the trace log"]
    #[doc = " @param as_hex If 0 treat the read_ptr as pointing at a string of text, otherwise treat it as data and print hex"]
    #[doc = " @return The number of bytes output or a negative integer if an error occured."]
    pub fn trace(
        mread_ptr: u32,
        mread_len: u32,
        dread_ptr: u32,
        dread_len: u32,
        as_hex: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Print some output to the trace log on xrpld along with a decimal number. Any xrpld instance set to \"trace\" log"]
    #[doc = " level will see this."]
    #[doc = " @param read_ptr A pointer to the string to output"]
    #[doc = " @param read_len The length of the string to output"]
    #[doc = " @param number Any integer you wish to display after the text"]
    #[doc = " @return A negative value on error"]
    pub fn trace_num(read_ptr: u32, read_len: u32, number: i64) -> i64;
}
extern "C" {
    #[doc = " Retrieve the burden of the originating transaction (if any)"]
    #[doc = " @return The burden of the originating transaction"]
    pub fn otxn_burden() -> i64;
}
extern "C" {
    #[doc = " Retrieve a field from the originating transaction as \"full text\" (The way it is displayed in JSON)"]
    #[doc = " @param write_ptr A buffer to write the representation into"]
    #[doc = " @param write_len The length of the buffer"]
    #[doc = " @param field_id The field code of the field being requested"]
    #[doc = " @return The number of bytes written to write_ptr or a negative integer if an error occured."]
    pub fn otxn_field_txt(write_ptr: u32, write_len: u32, field_id: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve a field from the originating transaction in its raw serialized form."]
    #[doc = " @param write_ptr A buffer to output the field into"]
    #[doc = " @param write_len The length of the buffer."]
    #[doc = " @param field_if The field code of the field being requested"]
    #[doc = " @return The number of bytes written to write_ptr or a negative integer if an error occured."]
    pub fn otxn_field(write_ptr: u32, write_len: u32, field_id: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve the generation of the originating transaction (if any)."]
    #[doc = " @return the generation of the originating transaction."]
    pub fn otxn_generation() -> i64;
}
extern "C" {
    #[doc = " Retrieve the TXNID of the originating transaction."]
    #[doc = " @param write_ptr A buffer at least 32 bytes long"]
    #[doc = " @param write_len The length of the buffer."]
    #[doc = " @return The number of bytes written into the buffer or a negative integer on failure."]
    pub fn otxn_id(write_ptr: u32, write_len: u32) -> i64;
}
extern "C" {
    #[doc = " Retrieve the Transaction Type (e.g. ttPayment = 0) of the originating transaction."]
    #[doc = " @return The Transaction Type (tt-code)"]
    pub fn otxn_type() -> i64;
}
extern "C" {
    pub fn float_set(exponent: i32, mantissa: i64) -> i64;
}
extern "C" {
    pub fn float_multiply(float1: i64, float2: i64) -> i64;
}
extern "C" {
    pub fn float_mulratio(float1: i64, round_up: u32, numerator: u32, denominator: u32) -> i64;
}
extern "C" {
    pub fn float_negate(float1: i64) -> i64;
}
extern "C" {
    pub fn float_compare(float1: i64, float2: i64, mode: u32) -> i64;
}
extern "C" {
    pub fn float_sum(float1: i64, float2: i64) -> i64;
}
extern "C" {
    pub fn float_sto(
        write_ptr: u32,
        write_len: u32,
        cread_ptr: u32,
        cread_len: u32,
        iread_ptr: u32,
        iread_len: u32,
        float1: i64,
        field_code: u32,
    ) -> i64;
}
extern "C" {
    pub fn float_sto_set(read_ptr: u32, read_len: u32) -> i64;
}
extern "C" {
    pub fn float_invert(float1: i64) -> i64;
}
extern "C" {
    pub fn float_divide(float1: i64, float2: i64) -> i64;
}
extern "C" {
    pub fn float_one() -> i64;
}
extern "C" {
    pub fn float_exponent(float1: i64) -> i64;
}
extern "C" {
    pub fn float_exponent_set(float1: i64, exponent: i32) -> i64;
}
extern "C" {
    pub fn float_mantissa(float1: i64) -> i64;
}
extern "C" {
    pub fn float_mantissa_set(float1: i64, mantissa: i64) -> i64;
}
extern "C" {
    pub fn float_sign(float1: i64) -> i64;
}
extern "C" {
    pub fn float_sign_set(float1: i64, negative: u32) -> i64;
}
extern "C" {
    pub fn float_int(float1: i64, decimal_places: u32, abs: u32) -> i64;
}
extern "C" {
    pub fn trace_float(mread_ptr: u32, mread_len: u32, float1: i64) -> i64;
}
